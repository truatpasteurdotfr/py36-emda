
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>emda_methods module &#8212; EMDA 1.1.3 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="emda_cmd_caller module" href="emda_cmd_caller.html" />
    <link rel="prev" title="Electron Microscopy Data Analytical Tool (EMDA)" href="../index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="emda_cmd_caller.html" title="emda_cmd_caller module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Electron Microscopy Data Analytical Tool (EMDA)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">EMDA 1.1.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">emda_methods module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-emda_methods">
<span id="emda-methods-module"></span><h1>emda_methods module<a class="headerlink" href="#module-emda_methods" title="Permalink to this headline">¶</a></h1>
<p>Author: “Rangana Warshamanage, Garib N. Murshudov”
MRC Laboratory of Molecular Biology</p>
<p>This software is released under the
Mozilla Public License, version 2.0; see LICENSE.</p>
<dl class="py function">
<dt id="emda_methods.apply_bfactor_to_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">apply_bfactor_to_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em>, <em class="sig-param"><span class="n">bf_arr</span></em>, <em class="sig-param"><span class="n">mapout</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.apply_bfactor_to_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an array of B-factors on the map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mapname: string</dt><dd><p>Map file name.</p>
</dd>
<dt>bf_arr: float, 1D array</dt><dd><p>An array/list of B-factors.</p>
</dd>
<dt>mapout: bool</dt><dd><p>If True, map for each B-factor will be output.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>all_mapout: complex, ndarray</dt><dd><p>4D array containing Fourier coefficients of all maps.
e.g. all_mapout[:,:,:,i], where i represents map number
corresponding to the B-factor in bf_arr.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.applymask">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">applymask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em>, <em class="sig-param"><span class="n">maskname</span></em>, <em class="sig-param"><span class="n">outname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.applymask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.average_maps">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">average_maps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maplist</span></em>, <em class="sig-param"><span class="n">rot</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">ncy</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">res</span><span class="o">=</span><span class="default_value">6</span></em>, <em class="sig-param"><span class="n">interp</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">fit</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tra</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fobj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">masklist</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.average_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the best average maps using Bayesian principles.</p>
<p>Calculates the best average map using Bayesian principles. This is done in two steps;
1. Parameter estimation using a likelihood function, 2. Best map calculation.
Parameter estimation is similar to map overlay where each map is brought onto
static map by maximizing the overlap. The best maps are calculated using
superimposed maps.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>maplist: list</dt><dd><p>List of half maps to average.</p>
</dd>
<dt>masklist: list, optional</dt><dd><p>List of masks to apply on maps. len(masklist) == len(maplist) // 2</p>
</dd>
<dt>rot: float, optional</dt><dd><p>Initial rotation in degrees. Default is 0.0.</p>
</dd>
<dt>axr: list, optional</dt><dd><p>Rotation axis. Default is [1, 0, 0].</p>
</dd>
<dt>tra: list, optional</dt><dd><p>Translation vector in fractional units. Default is [0.0, 0.0, 0.0]</p>
</dd>
<dt>res: float, optional</dt><dd><p>Fit start resolution in Angstrom units. Default is 6.0 Angstrom.</p>
</dd>
<dt>ncy: integer, optional</dt><dd><p>Number of fitting cycles. Default is 5.</p>
</dd>
<dt>interp: string, optional</dt><dd><p>Interpolation type either “linear” or “cubic”.
Default is linear.</p>
</dd>
<dt>fobj: string</dt><dd><p>File object for logging. If None given, EMDA_average.txt will be output.</p>
</dd>
<dt>fit: bool, optional</dt><dd><p>If True, map fitting will be carried out before average map calculation.
Default is True.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Outputs a series of overlaid maps (<a href="#id1"><span class="problematic" id="id2">fitted_map_</span></a>?.mrc).
Also, outputs a series of average maps (<a href="#id3"><span class="problematic" id="id4">avgmap_</span></a>?.mrc)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.balbes_data">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">balbes_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">map1name</span></em>, <em class="sig-param"><span class="n">map2name</span></em>, <em class="sig-param"><span class="n">fsccutoff</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'half'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.balbes_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns data required for Balbes pipeline.</p>
<p>Required data is output with their references in EMDA.xml.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>map1name: string</dt><dd><p>Name of the map 1.</p>
</dd>
<dt>map2name: string</dt><dd><p>Name of the map 2.</p>
</dd>
<dt>fsccutoff: float, optional</dt><dd><p>FSC of desired resolution. Defualt is 0.5</p>
</dd>
<dt>mode: string</dt><dd><p>Mode can be either ‘half’ or ‘any’. If the input maps are
the half maps, mode should be ‘half’. Otherwise, mode should be ‘any’.
Default mode is half.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Outputs EMDA.xml containing data and references to other data.
No return variables.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.bestmap">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">bestmap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hf1name</span></em>, <em class="sig-param"><span class="n">hf2name</span></em>, <em class="sig-param"><span class="n">outfile</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">knl</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.bestmap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.compositemap">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">compositemap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maps</span></em>, <em class="sig-param"><span class="n">masks</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.compositemap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.difference_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">difference_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maplist</span></em>, <em class="sig-param"><span class="n">masklist</span></em>, <em class="sig-param"><span class="n">smax</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'ampli'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.difference_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates difference map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>maplist: string</dt><dd><p>List of map names to calculate difference maps.</p>
</dd>
<dt>masklist: string</dt><dd><p>List of masks to apply on maps.</p>
</dd>
<dt>smax: float</dt><dd><p>Resolution to which difference map be calculated.</p>
</dd>
<dt>mode: string, optional</dt><dd><p>Different modes to scale maps. Three difference modes are supported.
‘ampli’ - scale between maps is based on amplitudes [Default].
‘power’ - scale between maps is based on powers (intensities).
‘norm’ - normalized maps are used to calculate difference map.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Outputs diffence maps and initial maps after scaling in MRC format.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.estimate_map_resol">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">estimate_map_resol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hfmap1name</span></em>, <em class="sig-param"><span class="n">hfmap2name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.estimate_map_resol" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates map resolution.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>hfmap1name: string</dt><dd><p>Halfmap 1 name.</p>
</dd>
<dt>hfmap2name: string</dt><dd><p>Halfmap 2 name.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>map_resol: float</dt><dd><p>Map resolution determined by the halfmap FSC.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.fouriersp_correlation">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">fouriersp_correlation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">half1_map</span></em>, <em class="sig-param"><span class="n">half2_map</span></em>, <em class="sig-param"><span class="n">kernel_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.fouriersp_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Fourier space local correlation using half maps.</p>
<dl>
<dt>Arguments:</dt><dd><dl>
<dt>Inputs:</dt><dd><dl class="simple">
<dt>half1_map: string</dt><dd><p>Name of half map 1.</p>
</dd>
<dt>half2_map: string</dt><dd><p>Name of half map 2.</p>
</dd>
<dt>kernel_size: integer, optional</dt><dd><p>Radius of integration kernal. Default is 5.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Following maps are written out:
fouriercorr3d_halfmaps.mrc - local correlation in half maps.
fouriercorr3d_fullmap.mrc - local correlation in full map</p>
<blockquote>
<div><p>using the formula 2 x FSC(half) / (1 + FSC(half)).</p>
</div></blockquote>
<dl class="simple">
<dt>fouriercorr3d_truemap.mrc - local correlation in true map.</dt><dd><p>Useful for validation purpose.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.get_biso_from_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">get_biso_from_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">halfmap1</span></em>, <em class="sig-param"><span class="n">halfmap2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.get_biso_from_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the isotropic B-value of the map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>halfmap1: string</dt><dd><p>Halfmap 1 file name.</p>
</dd>
<dt>halfmap2: string</dt><dd><p>Halfmap 2 file name.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>biso: float</dt><dd><p>Map B-iso value.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.get_biso_from_model">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">get_biso_from_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mmcif_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.get_biso_from_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the isotropic B-value of the model.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mmcif_file: string</dt><dd><p>mmCIF file name.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>biso: float</dt><dd><p>Model B-iso value.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.get_map_power">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">get_map_power</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.get_map_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the map power spectrum.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mapname: string</dt><dd><p>Map name.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>res_arr: float</dt><dd><p>Resolution array.</p>
</dd>
<dt>power_spectrum: float</dt><dd><p>Map power spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.get_variance">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">get_variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">half1name</span></em>, <em class="sig-param"><span class="n">half2name</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maskname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.get_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns noise and signal variances of half maps.</p>
<p>Returns noise and signal variances of half maps. Return values are not
corrected for full map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>half1name: string</dt><dd><p>Name of the half map 1.</p>
</dd>
<dt>half2name: string</dt><dd><p>Name of the half map 2.</p>
</dd>
<dt>filename: string</dt><dd><p>If present, statistics will be printed into this file.</p>
</dd>
<dt>maskname: String</dt><dd><p>If present, input maps will be masked before computing variances.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>res_arr: float, 1D array</dt><dd><p>Linear array of resolution in Angstrom units.</p>
</dd>
<dt>noisevar: float, 1D array</dt><dd><p>Linear array of noise variance in each resolution bin.</p>
</dd>
<dt>signalvar: float, 1D array</dt><dd><p>Linear array of signal variance in each resolution bin.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.half2full">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">half2full</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">half1name</span></em>, <em class="sig-param"><span class="n">half2name</span></em>, <em class="sig-param"><span class="n">outfile</span><span class="o">=</span><span class="default_value">'fullmap.mrc'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.half2full" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines half maps to generate full map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>half1name: string</dt><dd><p>Name of half map 1.</p>
</dd>
<dt>half2name: string</dt><dd><p>name of half map 2.</p>
</dd>
<dt>outfile: string, optional</dt><dd><p>Name of the output file. Default is fullmap.mrc</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>fullmap: float, 3D array</dt><dd><p>3D Numpy array of floats.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.halfmap_fsc">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">halfmap_fsc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">half1name</span></em>, <em class="sig-param"><span class="n">half2name</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maskname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.halfmap_fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Fourier Shell Correlation (FSC) using half maps.</p>
<p>Computes Fourier Shell Correlation (FSC) using half maps.
FSC is not corrected for mask effect in this implementation.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>half1name: string</dt><dd><p>Name of the half map 1.</p>
</dd>
<dt>half2name: string</dt><dd><p>Name of the half map 2.</p>
</dd>
<dt>filename: string</dt><dd><p>If present, statistics will be printed into this file.</p>
</dd>
<dt>maskname: String</dt><dd><p>If present, input maps will be masked before computing FSC.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>res_arr: float, 1D array</dt><dd><p>Linear array of resolution in Angstrom units.</p>
</dd>
<dt>bin_fsc: float, 1D array</dt><dd><p>Linear array of FSC in each resolution bin.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.lowpass_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">lowpass_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uc</span></em>, <em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">resol</span></em>, <em class="sig-param"><span class="n">filter</span><span class="o">=</span><span class="default_value">'ideal'</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.lowpass_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowpass filters a map to a specified resolution.</p>
<p>This function applies a lowpass filter on a map to a specified resolution.
This operations is carried out in the Fourier space. Note that lowpass map
will have the same shape as input data.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell params.</p>
</dd>
<dt>arr1: float, 3D array</dt><dd><p>3D Numpy array containing map values.</p>
</dd>
<dt>resol: float</dt><dd><p>Resolution cutoff for lowpass filtering in Angstrom units.</p>
</dd>
<dt>filter: string, optional</dt><dd><p>Fiter type to use in truncating Fourier coefficients.
Currently, only ‘ideal’ or ‘butterworth’ filters can be employed.
Default type is ideal.</p>
</dd>
<dt>order: integer, optional</dt><dd><p>Order of the Butterworth filter. Default is 4.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>fmap1: complex, 3D array</dt><dd><p>Lowpass filtered Fourier coefficeints.</p>
</dd>
<dt>map1: float, 3D array</dt><dd><p>Lowpass filtered map in image/real space</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.map2mtz">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">map2mtz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em>, <em class="sig-param"><span class="n">mtzname</span><span class="o">=</span><span class="default_value">'map2mtz.mtz'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.map2mtz" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a map into MTZ format.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mapname: string</dt><dd><p>Map file name.</p>
</dd>
<dt>mtzname: string</dt><dd><p>Output MTZ file name. Default is map2mtz.mtz</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Outputs MTZ file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.map2mtzfull">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">map2mtzfull</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uc</span></em>, <em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">arr2</span></em>, <em class="sig-param"><span class="n">mtzname</span><span class="o">=</span><span class="default_value">'halfnfull.mtz'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.map2mtzfull" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes several 3D Numpy arrays into an MTZ file.</p>
<p>This function accepts densities of two half maps as 3D numpy arrays
and outputs an MTZ file containing amplitudes of half1, half2 and
full map. The outfile data labels are H, K, L, Fout1, Fout2, Foutf, Poutf.
The last four labels correspond to amplitude of halfmap1, amplitudes of
halfmap2, amplitudes of fullmap and the phase values of fullmap, respectively.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell params.</p>
</dd>
<dt>arr1: float, 3D array</dt><dd><p>Half1 map values.</p>
</dd>
<dt>arr2: float, 3D array</dt><dd><p>Half2 map values.</p>
</dd>
<dt>mtzname: string, optional</dt><dd><p>Output MTZ file name. Default is halfnfull.mtz</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Outputs an MTZ file containing amplitudes of half maps and
full map.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.map_model_validate">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">map_model_validate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">half1map</span></em>, <em class="sig-param"><span class="n">half2map</span></em>, <em class="sig-param"><span class="n">modelfpdb</span></em>, <em class="sig-param"><span class="n">bfac</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">lig</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">model1pdb</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">modelresol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lgf</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.map_model_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates various FSCs for maps and model validation.</p>
<dl>
<dt>Arguments:</dt><dd><dl>
<dt>Inputs:</dt><dd><dl class="simple">
<dt>half1map: string</dt><dd><p>Name of half map 1.</p>
</dd>
<dt>half2map: string</dt><dd><p>Name of half map 2.</p>
</dd>
<dt>modelfpdb: string</dt><dd><p>Name of the model refined against full map in cif/pdb/ent
formats.</p>
</dd>
<dt>model1pdb: string, optional</dt><dd><p>Name of the model refined against one half map in cif/pdb/ent
formats. If included, FSC between that and half maps will be
calculated.</p>
</dd>
<dt>mask: string, optional</dt><dd><p>Name of the mask file. It will apply on half maps before
computing FSC. If not included, a correlation based masked will
employed.</p>
</dd>
<dt>modelresol: float, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Resolution to calculate model based map. If not specified, an FSC
based cutoff will be used.</p>
</dd>
<dt>bfac: float, optional</dt><dd><p>An overall B-factor for model map. Default is 0.0</p>
</dd>
<dt>lig: bool, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Set True, if there is a ligand in the model, but no description.
Default is False.</p>
</dd>
<dt>lgf: string, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Ligand description file (cif).</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>fsc_list: list</dt><dd><p>List of FSCs is returned. If len(fsc_list) is 4,
FSC lables are as follows:
0 - half maps FSC
1 - half1map - model1 FSC
2 - half2map - model1 FSC
3 - fullmap-fullmodel FSC
If len(fsc_list) is 2, only 0 and 3 contains.</p>
</dd>
</dl>
<p>Outputs FSCs in allmap_fsc_modelvsmap.eps</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.map_transform">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">map_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em>, <em class="sig-param"><span class="n">tra</span></em>, <em class="sig-param"><span class="n">rot</span></em>, <em class="sig-param"><span class="n">axr</span></em>, <em class="sig-param"><span class="n">outname</span><span class="o">=</span><span class="default_value">'transformed.mrc'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.map_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Imposes a transformation on a map.</p>
<p>Imposes a transformation (i.e. translation and rotation) on a map
and returns the transformed map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mapname: string</dt><dd><p>Name of the input map.</p>
</dd>
<dt>tra: list of three floats values</dt><dd><p>Translation vector as a list in Angstrom units.</p>
</dd>
<dt>rot: float</dt><dd><p>Rotation to apply in degrees.</p>
</dd>
<dt>axr: list of three integers</dt><dd><p>Axis to rotation. e.g [1, 0, 0]</p>
</dd>
<dt>outname: string, optional</dt><dd><p>Name of the transformed map. Default is transformed.mrc.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>transformed_map: float, 3D array</dt><dd><p>3D Numpy array of floats.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.mapmagnification">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">mapmagnification</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maplist</span></em>, <em class="sig-param"><span class="n">rmap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.mapmagnification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.mask_from_halfmaps">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">mask_from_halfmaps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uc</span></em>, <em class="sig-param"><span class="n">half1</span></em>, <em class="sig-param"><span class="n">half2</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">9</span></em>, <em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">iter</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">thresh</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.mask_from_halfmaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a mask from half maps.</p>
<p>Generates a mask from half maps based on real space local correlation.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell parameters.</p>
</dd>
<dt>half1: float, 3D array</dt><dd><p>Half map 1 data.</p>
</dd>
<dt>half2: float, 3D array</dt><dd><p>Half map 2 data.</p>
</dd>
<dt>radius: integer, optional</dt><dd><p>Radius of integrating kernel in voxels. Default is 9.</p>
</dd>
<dt>norm: bool, optional</dt><dd><p>If true, normalized maps will be used to generate correlation mask.
Default is False.</p>
</dd>
<dt>iter: integer,optional</dt><dd><p>Number of dilation cycles. Default is 1 cycle.</p>
</dd>
<dt>thresh: float, optional</dt><dd><p>Correlation cutoff for mask generation. Program automatically
decides the best value, however, user can overwrite this.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>mask: float, 3D array</dt><dd><p>3D Numpy array of correlation mask.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.mask_from_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">mask_from_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uc</span></em>, <em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">kern</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">resol</span><span class="o">=</span><span class="default_value">15</span></em>, <em class="sig-param"><span class="n">filter</span><span class="o">=</span><span class="default_value">'butterworth'</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">prob</span><span class="o">=</span><span class="default_value">0.99</span></em>, <em class="sig-param"><span class="n">itr</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">orig</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.mask_from_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a mask from a map.</p>
<p>Generates a mask from a map.</p>
<dl>
<dt>Arguments:</dt><dd><dl>
<dt>Inputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell parameters.</p>
</dd>
<dt>arr: float, 3D array</dt><dd><p>Map data.</p>
</dd>
<dt>half2: float, 3D array</dt><dd><p>Half map 2 data.</p>
</dd>
<dt>kern: integer, optional</dt><dd><p>Radius of integrating kernel in voxels. Default is 5.</p>
</dd>
<dt>resol: float, optional</dt><dd><p>Resolution cutoff for lowpass filtering in Angstrom units.
Default is 15 Angstrom.</p>
</dd>
<dt>filter: string,optional</dt><dd><p>Filter type to use with lowpass filtering. Default is butterworth.</p>
</dd>
<dt>order: integer, optional</dt><dd><p>Butterworth filter order. Default is 1.</p>
</dd>
<dt>prob: float, optional</dt><dd><p>Cumulative probability cutoff to decide the density threshold.
Default value is 0.99.</p>
</dd>
<dt>itr: integer, optional</dt><dd><p>Number of dilation cycles. Default is 3 cycles.</p>
</dd>
<dt>orig: list of three integer values.</dt><dd><p>Map origin. e.g. [0, 0, 0]</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>mask: float, 3D array</dt><dd><p>3D Numpy array of the mask.</p>
</dd>
</dl>
<p>Outputs lowpass.mrc and mapmask.mrc files.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.mirror_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">mirror_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.mirror_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.model2map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">model2map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modelxyz</span></em>, <em class="sig-param"><span class="n">dim</span></em>, <em class="sig-param"><span class="n">resol</span></em>, <em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">bfac</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">lig</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ligfile</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.model2map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.mtz2map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">mtz2map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mtzname</span></em>, <em class="sig-param"><span class="n">map_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.mtz2map" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an MTZ file into MRC format.</p>
<p>This function converts data in an MTZ file into a 3D Numpy array.
It combines amplitudes and phases with “Fout0” and
“Pout0” labels to form Fourier coefficients. If the MTZ contains
several aplitude columns, only the one corresponding to “Fout0”
will be used.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mtzname: string</dt><dd><p>MTZ file name.</p>
</dd>
<dt>map_size: list</dt><dd><p>Shape of output 3D Numpy array as a list of three integers.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>outarr: float
3D Numpy array of map values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.overall_cc">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">overall_cc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">map1name</span></em>, <em class="sig-param"><span class="n">map2name</span></em>, <em class="sig-param"><span class="n">space</span><span class="o">=</span><span class="default_value">'real'</span></em>, <em class="sig-param"><span class="n">maskname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.overall_cc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.overlay_maps">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">overlay_maps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maplist</span></em>, <em class="sig-param"><span class="n">rot</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">ncy</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">res</span><span class="o">=</span><span class="default_value">6</span></em>, <em class="sig-param"><span class="n">interp</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">hfm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">masklist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tra</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.overlay_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Superimposes several maps.</p>
<p>Superimposes several maps using a likelihood function. All maps are
overlaid on the first map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>maplist: list</dt><dd><p>List of maps to overlay.</p>
</dd>
<dt>masklist: list</dt><dd><p>List of masks to apply on maps.</p>
</dd>
<dt>rot: float, optional</dt><dd><p>Initial rotation in degrees. Default is 0.0.</p>
</dd>
<dt>axr: list, optional</dt><dd><p>Rotation axis. Default is [1, 0, 0].</p>
</dd>
<dt>tra: list, optional</dt><dd><p>Translation vector in fractional units. Default is [0.0, 0.0, 0.0]</p>
</dd>
<dt>res: float, optional</dt><dd><p>Fit start resolution in Angstrom units. Default is 6.0 Angstrom.</p>
</dd>
<dt>ncy: integer, optional</dt><dd><p>Number of fitting cycles. Default is 5.</p>
</dd>
<dt>interp: string, optional</dt><dd><p>Interpolation type either “linear” or “cubic”.
Default is linear.</p>
</dd>
<dt>hfm: bool, optional</dt><dd><p>If True, overlay will be carried out on half maps. In this case,
maplist will contain half maps.
e.g. [map1_half1.mrc, map1_half2.mrc, map2_half1.mrc, map2_half2.mrc, …].
masklist will contain masks for each map. e.g. [map1_mask.mrc, map2_mask.mrc].
The length of masklist should be equal to half the length of maplist.
If False, uses full maps for overlay. Default is False.</p>
</dd>
<dt>fobj: string</dt><dd><p>File object for logging. If None given, EMDA_overlay.txt will be output.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Outputs a series of overlaid maps (<a href="#id5"><span class="problematic" id="id6">fitted_map_</span></a>?.mrc).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.predict_fsc">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">predict_fsc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hf1name</span></em>, <em class="sig-param"><span class="n">hf2name</span></em>, <em class="sig-param"><span class="n">nparticles</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bfac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.predict_fsc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.prepare_refmac_data">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">prepare_refmac_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hf1name</span></em>, <em class="sig-param"><span class="n">hf2name</span></em>, <em class="sig-param"><span class="n">outfile</span><span class="o">=</span><span class="default_value">'fullmap.mtz'</span></em>, <em class="sig-param"><span class="n">bfac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maskname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xmlobj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fsccutoff</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.prepare_refmac_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.read_atomsf">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">read_atomsf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atom</span></em>, <em class="sig-param"><span class="n">fpath</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.read_atomsf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.read_map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">read_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.read_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads CCP4 type map (.map) or MRC type map.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mapname: string</dt><dd><p>CCP4/MRC map file name</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell</p>
</dd>
<dt>arr: float, 3D array</dt><dd><p>Map values as Numpy array</p>
</dd>
<dt>origin: list</dt><dd><p>Map origin list</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.read_mtz">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">read_mtz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mtzfile</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.read_mtz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads mtzfile and returns unit_cell and data in Pandas DataFrame.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mtzfile: string</dt><dd><p>MTZ file name</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell</p>
</dd>
<dt>df: Pandas data frame</dt><dd><p>Map values in Pandas Dataframe</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.realsp_correlation">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">realsp_correlation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">half1map</span></em>, <em class="sig-param"><span class="n">half2map</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">lig</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">model_resol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_map</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lgf</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.realsp_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates local correlation in real/image space.</p>
<dl>
<dt>Arguments:</dt><dd><dl>
<dt>Inputs:</dt><dd><dl class="simple">
<dt>half1map: string</dt><dd><p>Name of half map 1.</p>
</dd>
<dt>half1map: string</dt><dd><p>Name of half map 2.</p>
</dd>
<dt>kernel_size: integer, optional</dt><dd><p>Radius of integration kernal. Default is 5.</p>
</dd>
<dt>norm: bool, optional</dt><dd><p>If True, correlation will be carried out on normalized maps.
Default is False.</p>
</dd>
<dt>model: string, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Name of model file (cif/pdb). If present, map-model local
correlation will be calculated.</p>
</dd>
<dt>model_resol: float, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Resolution to calculate model based map. If absent, FSC based
resolution cutoff will be employed.</p>
</dd>
<dt>mask_map: string, optional</dt><dd><p>Mask file to apply on correlation maps. If not given, correlation based
mask will be employed.</p>
</dd>
<dt>lig: bool, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Set True, if there is a ligand in the model, but no description.
Default is False.</p>
</dd>
<dt>lgf: string, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Ligand description file (cif).</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Following maps are written out:
rcc_halfmap_smax?.mrc - reals space half map local correlation.
rcc_fullmap_smax?.mrc - correlation map corrected to full map</p>
<blockquote>
<div><p>using the formula 2 x FSC(half) / (1 + FSC(half)).</p>
</div></blockquote>
<p>If a model included, then
rcc_mapmodel_smax?.mrc - local correlation map between model and</p>
<blockquote>
<div><p>full map.</p>
</div></blockquote>
<dl class="simple">
<dt>rcc_truemapmodel_smax?.mrc - truemap-model correaltion map for</dt><dd><p>validation purpose.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.realsp_correlation_mapmodel">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">realsp_correlation_mapmodel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullmap</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">resol</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">lig</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">trimpx</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">mask_map</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lgf</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.realsp_correlation_mapmodel" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates real space local correlation between map and model.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>fullmap: string</dt><dd><p>Name of the map.</p>
</dd>
<dt>model: string</dt><dd><p>An argument for model based map calculation using REFMAC.
Name of model file (cif/pdb/ent/mtz/mrc).</p>
</dd>
<dt>resol: float</dt><dd><p>An argument for model based map calculation using REFMAC.
Resolution to calculate model based map.</p>
</dd>
<dt>kernel_size: integer, optional</dt><dd><p>Radius of integration kernal. Default is 5.</p>
</dd>
<dt>mask_map: string, optional</dt><dd><p>Mask file to apply on correlation maps. If not given, a spherical mask
will be employed. Default radius = (map.shape[0] // 2) - trimpx</p>
</dd>
<dt>trimpx: integer, optional</dt><dd><p>Parameter to adjust the radius (in pixels) of the spherical mask
in the absence of mask_map argument. default is 1.</p>
</dd>
<dt>lig: bool, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Set True, if there is a ligand in the model, but no description.
Default is False.</p>
</dd>
<dt>lgf: string, optional</dt><dd><p>An argument for model based map calculation using REFMAC.
Ligand description file (cif).</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Following maps are written out:
modelmap.mrc - model based map.
rcc_mapmodel.mrc - real space local correlation map.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.resample_data">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">resample_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curnt_pix</span></em>, <em class="sig-param"><span class="n">targt_pix</span></em>, <em class="sig-param"><span class="n">targt_dim</span></em>, <em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.resample_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples a 3D array.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>curnt_pix: float</dt><dd><p>Current pixel size.</p>
</dd>
<dt>targt_pix: float</dt><dd><p>Target pixel size.</p>
</dd>
<dt>targt_dim: list</dt><dd><p>List of three integer values.</p>
</dd>
<dt>arr: float</dt><dd><p>3D array of map values.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>new_arr: float, 3D array</dt><dd><p>Resampled 3D array.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.scale_map2map">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">scale_map2map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">staticmap</span></em>, <em class="sig-param"><span class="n">map2scale</span></em>, <em class="sig-param"><span class="n">outfile</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.scale_map2map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="emda_methods.singlemap_fsc">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">singlemap_fsc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">map1name</span></em>, <em class="sig-param"><span class="n">knl</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.singlemap_fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Fourier Shell Correlation (FSC) of a map.</p>
<p>Computes Fourier Shell Correlation (FSC) between a map and its
reconstituted other half from neighbough Fourier coefficients.
This method can be used to estimate FSC based resolution. However,
results seem to be reliable when an unfiltered map is used.</p>
<dl>
<dt>Arguments:</dt><dd><dl>
<dt>Inputs:</dt><dd><dl class="simple">
<dt>map1name: string</dt><dd><p>Name of the map.</p>
</dd>
<dt>knl: integer, optional</dt><dd><p>Radius of the integrating kernel.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>res_arr: float, 1D array</dt><dd><p>Linear array of resolution in Angstrom units.</p>
</dd>
<dt>bin_fsc: float, 1D array</dt><dd><p>Linear array of FSC in each resolution bin.</p>
</dd>
</dl>
<p>Outputs reconstituted map as ‘fakehalf.mrc’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.sphere_kernel_softedge">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">sphere_kernel_softedge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.sphere_kernel_softedge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a soft-edged spherical kernel.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>radius: integer, optional</dt><dd><p>Radius of integrating kernel in voxels. Default is 5.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>kernel: float, 3D array</dt><dd><p>3D Numpy array of spherical kernel.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.twomap_fsc">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">twomap_fsc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">map1name</span></em>, <em class="sig-param"><span class="n">map2name</span></em>, <em class="sig-param"><span class="n">fobj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xmlobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.twomap_fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Fourier Shell Correlation (FSC) between any two maps.</p>
<p>Computes Fourier Shell Correlation (FSC) using any two maps.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>map1name: string</dt><dd><p>Name of the map 1.</p>
</dd>
<dt>map2name: string</dt><dd><p>Name of the map 2.</p>
</dd>
<dt>fobj: file object for logging</dt><dd><p>If present, statistics will be printed into this file.</p>
</dd>
<dt>xmlobj: xml object</dt><dd><p>If present, statistics will be printed into an XML file.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><dl class="simple">
<dt>res_arr: float, 1D array</dt><dd><p>Linear array of resolution in Angstrom units.</p>
</dd>
<dt>bin_fsc: float, 1D array</dt><dd><p>Linear array of FSC in each resolution bin.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.write_mrc">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">write_mrc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapdata</span></em>, <em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">unit_cell</span></em>, <em class="sig-param"><span class="n">map_origin</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.write_mrc" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes 3D Numpy array into MRC file.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>mapdata: float, 3D array</dt><dd><p>Map values to write</p>
</dd>
<dt>filename: string</dt><dd><p>Output file name</p>
</dd>
<dt>unit_cell: float, 1D array</dt><dd><p>Unit cell params</p>
</dd>
<dt>map_origin: list, optional</dt><dd><p>map origin. Default is [0.0, 0.0, 0.0]</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>Output MRC file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emda_methods.write_mtz">
<code class="sig-prename descclassname">emda_methods.</code><code class="sig-name descname">write_mtz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uc</span></em>, <em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">outfile</span><span class="o">=</span><span class="default_value">'map2mtz.mtz'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emda_methods.write_mtz" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes 3D Numpy array into MTZ file.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>Inputs:</dt><dd><dl class="simple">
<dt>uc: float, 1D array</dt><dd><p>Unit cell params.</p>
</dd>
<dt>arr: complex, 3D array</dt><dd><p>Map values to write.</p>
</dd>
</dl>
</dd>
<dt>Outputs:</dt><dd><p>outfile: string
Output file name. Default is map2mtz.mtz.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="../index.html"
                        title="previous chapter">Electron Microscopy Data Analytical Tool (EMDA)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="emda_cmd_caller.html"
                        title="next chapter">emda_cmd_caller module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/rst/emda_methods.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="emda_cmd_caller.html" title="emda_cmd_caller module"
             >next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Electron Microscopy Data Analytical Tool (EMDA)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">EMDA 1.1.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">emda_methods module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Rangana Warshamanage, Garib N. Murshudov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>